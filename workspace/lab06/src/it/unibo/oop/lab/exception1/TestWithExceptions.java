package it.unibo.oop.lab.exception1;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import org.junit.Test;

/**
 * Example testing class that illustrates two possible patterns to make good
 * tests when exceptions are involved.
 */
public class TestWithExceptions {

    /**
     * This is a test where we do not expect any exception to be generated. If
     * one exception is generated, then it must fail.
     */
    @Test
    public void testExceptionNotExpected() {
        try {
            Class.forName("java.util.ArrayList").newInstance();
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {
            /*
             * Same behaviour for any exception: use multi-catch.
             * 
             * Do not catch generic Exceptions: if they are unforeseen, it is
             * better to let the test fail badly, so that the developer is
             * informed that it is not a "normal" failure.
             */
            fail(e.getMessage());
        }
    }

    /**
     * This is a test where we do expect an exception to be raised. If not, the
     * test must fail.
     */
    @Test
    public void testExceptionExpected() {
        try {
            Class.forName("java.util.List").newInstance();
            /*
             * If we get to the next line, then we have not generated any exception. The test must fail().
             */
            fail();
        } catch (InstantiationException e) {
            /*
             * We expect this exception, and none other (List must exist in the
             * classpath, but it can't be instanced being an interface.
             * 
             * Since an empty catch block is pretty bad looking, what we can do
             * is for instance a quality check on the generated exception. In
             * this case a good quality exception will be generated by the Java
             * libraries, but if you are catching an exception thrown by some
             * less reliable library, it may be a good idea to verify that, for
             * instance:
             * 
             * - it holds a message - the message is not an empty String
             */
            assertNotNull(e.getMessage());
            assertFalse(e.getMessage().isEmpty());
        } catch (ClassNotFoundException | IllegalAccessException e) {
            /*
             * These are theorethically possible, but not expected exceptions.
             * To deal with them, we use a second catch block, and we raise an
             * explicit fail.
             */
            fail(e.getMessage());
        }
    }
}
